# Implementation Plan: template-uv-mcp-server

A reusable template for building MCP (Model Context Protocol) servers using the Python SDK with `uv` as the dependency manager and runtime tool.

## Overview

This template follows the official [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk) best practices and provides a starting point for creating custom MCP servers that can be used with Claude Desktop and other MCP clients.

---

## Directory Structure

```
template-uv-mcp-server/
├── .gitignore
├── .python-version           # Python version pin (3.11+)
├── LICENSE
├── README.md                 # Usage documentation
├── PLAN.md                   # This file
├── pyproject.toml            # Project configuration & dependencies
├── uv.lock                   # Lock file (generated by uv)
└── src/
    └── template_uv_mcp_server/
        ├── __init__.py       # Package init with version
        ├── __main__.py       # Entry point for `python -m`
        └── server.py         # Main MCP server implementation
```

---

## Required Files and Their Purposes

### 1. `pyproject.toml`

Project configuration file following PEP 621 standards. Key sections:

```toml
[project]
name = "template-uv-mcp-server"
version = "0.1.0"
description = "A reusable template for MCP servers using uv"
readme = "README.md"
requires-python = ">=3.11"
dependencies = [
    "mcp[cli]>=1.0.0",
]

[project.scripts]
template-uv-mcp-server = "template_uv_mcp_server:main"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/template_uv_mcp_server"]
```

### 2. `.python-version`

Specifies the Python version for uv:

```
3.11
```

### 3. `src/template_uv_mcp_server/__init__.py`

Package initialization:

```python
from .server import main

__version__ = "0.1.0"
__all__ = ["main", "__version__"]
```

### 4. `src/template_uv_mcp_server/__main__.py`

Enables running as module (`python -m template_uv_mcp_server`):

```python
from .server import main

if __name__ == "__main__":
    main()
```

### 5. `src/template_uv_mcp_server/server.py`

Main server implementation using FastMCP:

```python
"""
Template MCP Server

A reusable starting point for building MCP servers.
Customize the tools, resources, and prompts for your use case.
"""

from mcp.server.fastmcp import FastMCP

# Create the MCP server instance
mcp = FastMCP("Template Server")


# Example tool
@mcp.tool()
def hello(name: str = "World") -> str:
    """Say hello to someone."""
    return f"Hello, {name}!"


# Example resource
@mcp.resource("template://info")
def get_info() -> str:
    """Get template information."""
    return "This is a template MCP server. Customize it for your needs!"


# Example prompt
@mcp.prompt()
def greeting_prompt(name: str) -> str:
    """Generate a greeting prompt."""
    return f"Please write a friendly greeting for {name}."


def main():
    """Entry point for the MCP server."""
    mcp.run()


if __name__ == "__main__":
    main()
```

### 6. `.gitignore`

Standard Python gitignore plus uv-specific entries:

```
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
.venv/
venv/
ENV/

# uv
.uv/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Testing
.pytest_cache/
.coverage
htmlcov/

# Type checking
.mypy_cache/
```

### 7. `README.md`

Documentation with installation, usage, and customization instructions.

---

## Implementation Steps

### Phase 1: Project Setup

1. **Initialize with uv**
   ```bash
   cd /Users/ezequielmrivero/eze/custom_mcps/template-uv-mcp-server
   uv init --name template-uv-mcp-server
   ```

2. **Add MCP dependency**
   ```bash
   uv add "mcp[cli]"
   ```

3. **Create src layout**
   ```bash
   mkdir -p src/template_uv_mcp_server
   touch src/template_uv_mcp_server/__init__.py
   touch src/template_uv_mcp_server/__main__.py
   touch src/template_uv_mcp_server/server.py
   ```

### Phase 2: Core Implementation

4. **Implement `server.py`** with FastMCP following the SDK quickstart:
   - Create FastMCP instance with server name
   - Add example tool with `@mcp.tool()` decorator
   - Add example resource with `@mcp.resource()` decorator
   - Add example prompt with `@mcp.prompt()` decorator
   - Create `main()` entry point calling `mcp.run()`

5. **Configure `pyproject.toml`**:
   - Set project metadata
   - Define console script entry point
   - Configure hatchling build backend
   - Set source layout path

6. **Create `__init__.py` and `__main__.py`**:
   - Export `main` function
   - Enable module execution

### Phase 3: Testing & Validation

7. **Sync dependencies**
   ```bash
   uv sync --dev --all-extras
   ```

8. **Test with MCP dev tools**
   ```bash
   uv run mcp dev src/template_uv_mcp_server/server.py
   ```

9. **Test direct execution**
   ```bash
   uv run template-uv-mcp-server
   # or
   uv run python -m template_uv_mcp_server
   ```

### Phase 4: Documentation

10. **Create comprehensive README.md** covering:
    - Quick start guide
    - Installation instructions
    - Claude Desktop configuration
    - Customization guide
    - Development workflow

---

## Configuration for Claude Desktop

### Installation Command

```bash
uv run mcp install src/template_uv_mcp_server/server.py --name "Template Server"
```

### Manual Configuration

Add to Claude Desktop config file:

**macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
**Windows**: `%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "template-server": {
      "command": "uv",
      "args": [
        "--directory",
        "/Users/ezequielmrivero/eze/custom_mcps/template-uv-mcp-server",
        "run",
        "template-uv-mcp-server"
      ]
    }
  }
}
```

### Alternative: Using uvx (for published packages)

```json
{
  "mcpServers": {
    "template-server": {
      "command": "uvx",
      "args": ["template-uv-mcp-server"]
    }
  }
}
```

---

## Best Practices from Python SDK

### 1. Use FastMCP for High-Level API
FastMCP provides a simpler, decorator-based approach compared to the low-level server implementation.

### 2. Tool Design
- Use type hints for all parameters and return types
- Provide clear docstrings (used as tool descriptions)
- Tools can perform side effects (like POST endpoints)
- Use `Context` parameter for accessing MCP capabilities

```python
from mcp.server.fastmcp import Context, FastMCP

@mcp.tool()
async def my_tool(param: str, ctx: Context) -> str:
    """Tool description shown to LLM."""
    await ctx.info("Processing...")
    return result
```

### 3. Resource Design
- Resources expose data (like GET endpoints)
- Should not perform significant computation
- Use URI templates for dynamic resources

```python
@mcp.resource("file://documents/{name}")
def read_document(name: str) -> str:
    """Read a document by name."""
    return f"Content of {name}"
```

### 4. Prompt Design
- Prompts are reusable templates for LLM interactions
- Can return strings or lists of messages

```python
from mcp.server.fastmcp.prompts import base

@mcp.prompt()
def review_code(code: str) -> list[base.Message]:
    return [
        base.UserMessage("Please review this code:"),
        base.UserMessage(code),
    ]
```

### 5. Lifespan Management
For resources that need setup/cleanup:

```python
from contextlib import asynccontextmanager
from collections.abc import AsyncIterator

@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[dict]:
    # Setup
    db = await Database.connect()
    try:
        yield {"db": db}
    finally:
        # Cleanup
        await db.disconnect()

mcp = FastMCP("My App", lifespan=app_lifespan)
```

### 6. Structured Output
Use Pydantic models or TypedDicts for validated structured responses:

```python
from pydantic import BaseModel

class WeatherData(BaseModel):
    temperature: float
    condition: str

@mcp.tool()
def get_weather(city: str) -> WeatherData:
    return WeatherData(temperature=22.5, condition="sunny")
```

### 7. Development Workflow
```bash
# Development with MCP Inspector
uv run mcp dev server.py

# Add dependencies during development
uv run mcp dev server.py --with pandas --with numpy

# Install in Claude Desktop
uv run mcp install server.py --name "My Server"

# Run with environment variables
uv run mcp install server.py -v API_KEY=xxx -f .env
```

---

## Transport Options

### stdio (Default)
Default transport, used by Claude Desktop:
```python
mcp.run()  # Uses stdio by default
```

### Streamable HTTP
For web deployments:
```python
mcp.run(transport="streamable-http")
```

### SSE (Legacy)
```python
mcp.run(transport="sse")
```

---

## Extending the Template

### Adding New Tools
```python
@mcp.tool()
def my_new_tool(param1: str, param2: int = 10) -> dict:
    """Description of what this tool does."""
    return {"result": f"{param1} processed with {param2}"}
```

### Adding New Resources
```python
@mcp.resource("myapp://config/{key}")
def get_config(key: str) -> str:
    """Get configuration value."""
    return config.get(key, "default")
```

### Adding Dependencies
```bash
uv add requests  # Add new dependency
uv add --dev pytest  # Add dev dependency
```

---

## Checklist

- [ ] Create directory structure
- [ ] Initialize uv project
- [ ] Add mcp[cli] dependency
- [ ] Implement server.py with FastMCP
- [ ] Configure pyproject.toml with entry points
- [ ] Create __init__.py and __main__.py
- [ ] Add .gitignore and .python-version
- [ ] Write comprehensive README.md
- [ ] Test with `uv run mcp dev`
- [ ] Test Claude Desktop integration
- [ ] Verify all example tools/resources/prompts work

---

## References

- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)
- [MCP Documentation](https://modelcontextprotocol.io)
- [MCP Specification](https://modelcontextprotocol.io/specification/latest)
- [uv Documentation](https://docs.astral.sh/uv/)
- [FastMCP Examples](https://github.com/modelcontextprotocol/python-sdk/tree/main/examples)
